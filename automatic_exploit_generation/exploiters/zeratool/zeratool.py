import pickle
import typing

import docker
import grpc

from automatic_exploit_generation.configuration import Configuration
from automatic_exploit_generation.exploiters.base_exploiter import (
    BaseExploiter,
)
from automatic_exploit_generation.exploiters.zeratool.protobuf import (
    exploit_pb2,
    exploit_pb2_grpc,
)
from commons.exploit import Exploit
from commons.input_streams import InputStreams
from commons.mitigations import Mitigations
from commons.outcomes import Outcomes
from commons.payload import Payload
from commons.sensitive_functions import (
    SensitiveFunction,
    get_sensitive_functions_names,
)
from commons.weaknesses import Weaknesses


def _is_sublist_of_list(needle: list, stack: list) -> bool:
    return set(needle).issubset(set(stack))


class Zeratool(BaseExploiter):
    def _is_exploitation_supported(self) -> bool:
        # Zeratool supports only one input stream at each exploitation attempt.
        supported_input_streams = [
            InputStreams.STDIN,
            InputStreams.ARGUMENTS,
        ]
        if (
            len(self._input_streams) != 1
            and self._input_streams[0] not in supported_input_streams
        ):
            return False

        supported_mitigations = [
            Mitigations.ASLR,
            Mitigations.NX,
            Mitigations.CANARIES,
            Mitigations.NX,
        ]
        if not _is_sublist_of_list(self._mitigations, supported_mitigations):
            return False

        supported_weaknesses = [
            Weaknesses.TAINTED_FORMAT_STRING,
            Weaknesses.STACK_OUT_OF_BOUND_WRITE,
        ]
        if self._weakness not in supported_weaknesses:
            return False

        return True

    def _run_exploitation_in_container(
        self,
        overflow_only: bool = False,
        format_only: bool = False,
        win_funcs: list = None,
    ) -> Exploit:
        client = docker.from_env()
        # container = client.containers.run(
        #     Configuration.ZERATOOL_IMAGE_NAME,
        #     detach=True,
        #     tty=True,
        #     ports={"13000/tcp": 13000},
        #     publish_all_ports=True,
        # )
        # container_ip = container.attrs["NetworkSettings"]["IPAddress"]
        exploit = self._request_exploitation_to_grpc_service(
            "172.17.0.2", overflow_only, format_only, win_funcs
        )

        container.remove(force=True)

        return exploit

    def _request_exploitation_to_grpc_service(
        self,
        container_ip: str,
        overflow_only: bool = False,
        format_only: bool = False,
        win_funcs: list = None,
    ) -> Exploit:
        channel = grpc.insecure_channel(container_ip + ":13000")
        stub = exploit_pb2_grpc.ExploitServiceStub(channel)

        binary_arg = open(self._filename, "rb").read()
        input_stream_arg = self._input_streams[0].name
        serialized_win_funcs_arg = ",".join(win_funcs) if win_funcs else ""

        query = exploit_pb2.exploitationRequest(
            binary=binary_arg,
            input_stream=input_stream_arg,
            overflow_only=overflow_only,
            format_only=format_only,
            serialized_win_funcs=serialized_win_funcs_arg,
        )
        response = stub.Exploit(query)
        exploit = pickle.loads(response.pickledExploit)

        return exploit

    def _exploit(self) -> Exploit:
        overflow_only = self._weakness == Weaknesses.STACK_OUT_OF_BOUND_WRITE
        format_only = self._weakness == Weaknesses.TAINTED_FORMAT_STRING
        win_funcs = list(get_sensitive_functions_names(self._filename))
        win_funcs_names = self._get_win_funcs_names(win_funcs)

        # Execute the attack iwth
        for with_win in [True, False]:
            if with_win:
                if win_funcs_names:
                    win_funcs_used = win_funcs_names
                else:
                    continue
            else:
                win_funcs_used = None

            exploit = self._run_exploitation_in_container(
                overflow_only, format_only, win_funcs_used
            )
            if exploit:
                return exploit

        return None

    def _get_win_funcs_names(
        self, win_funcs: typing.List[SensitiveFunction]
    ) -> typing.List[str]:
        return [func.name for func in win_funcs]
